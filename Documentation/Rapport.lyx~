#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language french
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style french
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language=C,keywordstyle={\color{blue}},commentstyle={\color{magenta}\itshape},emphstyle={\color{red}},breaklines=true,basicstyle={\ttfamily},stringstyle={\color{green}},identifierstyle={\color{cyan}}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Rapport de projet mathématiques : Méthodes numériques pour la résolution
 de systèmes linéaires
\end_layout

\begin_layout Author
Alix ANNERAUD - Amandine BURCON - Myriem ABID
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\reel}{\mathbb{R}}
{\mathbb{R}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section*
Sommaire
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
La résolution des systèmes linéaires est utile à un bon nombres de domaines.
 Voici quelques exemples de problèmes que nous avons rencontrés précédemment
 :
\end_layout

\begin_layout Itemize

\bar under
Électricité (P3) :
\bar default
 Calcul d'intensité dans un circuit électronique en utilisant les lois des
 noeuds / mailles.
\end_layout

\begin_layout Itemize

\bar under
Chimie (C3) :
\bar default
 Calcul de l’équilibre des équations des réactions chimiques.
\end_layout

\begin_layout Itemize

\bar under
Algèbre linéaire (M4) :
\bar default
 Recherche des vecteurs propres d’une matrice carrée associés à une valeur
 propre donnée, déterminer le noyau d’un endomorphisme en dimension finie
 (système homogène).
\end_layout

\begin_layout Itemize

\bar under
Géométrie analytique (Projet Informatique):
\bar default
 Déterminer la position relative de droite et de plan dans l’espace.
\end_layout

\begin_layout Standard
Nous allons nous intéresser au dernier cas, où nous devions, en projet informati
que, détecter et déterminer la collision entre un parallélépipède rectangle
 (
\begin_inset Formula $IJKLMNOP$
\end_inset

) et une droite (
\begin_inset Formula $D$
\end_inset

).
 
\end_layout

\begin_layout Standard
En images de synthèse, les objets dans l'espaces sont définis par des points
 dans 
\begin_inset Formula $\reel^{3}$
\end_inset

.
\end_layout

\begin_layout Standard
Ainsi, pour une droite définie par les points 
\begin_inset Formula $A$
\end_inset

 et 
\begin_inset Formula $B$
\end_inset

, il est relativement aisé de retrouver son vecteur directeur : 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\overrightarrow{D}=\overrightarrow{AB}=\begin{pmatrix}x_{B}-x_{A}\\
y_{B}-y_{A}\\
z_{B}-z_{A}
\end{pmatrix}
\]

\end_inset


\end_layout

\begin_layout Standard
Ensuite, à partir du parallélépipède rectangle, on peut déterminer une base
 de l'espace :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\alpha\times\overrightarrow{JI}+\beta\times\overrightarrow{JK}+\gamma\times\overrightarrow{JL}=\alpha\times\begin{pmatrix}x_{I}-x_{J}\\
y_{I}-y_{J}\\
z_{I}-z_{J}
\end{pmatrix}+\beta\times\begin{pmatrix}x_{K}-x_{J}\\
y_{K}-y_{J}\\
z_{K}-z_{J}
\end{pmatrix}+\gamma\begin{pmatrix}x_{L}-x_{J}\\
y_{L}-y_{J}\\
z_{L}-z_{J}
\end{pmatrix},\forall\alpha,\beta,\gamma\in\reel
\]

\end_inset


\end_layout

\begin_layout Standard
Ainsi, on peut exprimer la le vecteur 
\begin_inset Formula $\overrightarrow{D}$
\end_inset

, c'est à dire déterminer les valeurs de 
\begin_inset Formula $\alpha,\beta$
\end_inset

 et 
\begin_inset Formula $\gamma$
\end_inset

 :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\alpha\times\overrightarrow{JI}+\beta\times\overrightarrow{JK}+\gamma\times\overrightarrow{JL}=\overrightarrow{D}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\alpha\times\begin{pmatrix}x_{I}-x_{J}\\
y_{I}-y_{J}\\
z_{I}-z_{J}
\end{pmatrix}+\beta\times\begin{pmatrix}x_{K}-x_{J}\\
y_{K}-y_{J}\\
z_{K}-z_{J}
\end{pmatrix}+\gamma\begin{pmatrix}x_{L}-x_{J}\\
y_{L}-y_{J}\\
z_{L}-z_{J}
\end{pmatrix}=\begin{pmatrix}x_{B}-x_{A}\\
y_{B}-y_{A}\\
z_{B}-z_{A}
\end{pmatrix}
\]

\end_inset


\end_layout

\begin_layout Standard
On a donc une équation matricielle de la forme :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
AX=B
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\underbrace{\begin{pmatrix}x_{I}-x_{J} & x_{K}-x_{J} & x_{L}-x_{J}\\
y_{I}-y_{J} & y_{K}-y_{J} & y_{L}-y_{J}\\
z_{I}-z_{J} & z_{K}-z_{J} & z_{L}-z_{J}
\end{pmatrix}}_{A}\underbrace{\begin{pmatrix}\alpha\\
\beta\\
\gamma
\end{pmatrix}}_{X}=\underbrace{\begin{pmatrix}x_{B}-x_{A}\\
y_{B}-y_{A}\\
z_{B}-z_{A}
\end{pmatrix}}_{B}
\]

\end_inset


\end_layout

\begin_layout Standard
Une fois trouvé 
\begin_inset Formula $\alpha,\beta$
\end_inset

 et 
\begin_inset Formula $\gamma$
\end_inset

 (
\begin_inset Formula $X$
\end_inset

), on connaît alors la position relative de la droite 
\begin_inset Formula $D$
\end_inset

 par rapport au parallélépipède rectangle.
 Ainsi, avec de simples comparaisons, on peut déduire si la droite est en
 collision avec le parallélépipède rectangle, et si oui, a quels endroits.
\end_layout

\begin_layout Subsection
Théorie
\end_layout

\begin_layout Standard
Notre but sera de résoudre pour 
\begin_inset Formula $X$
\end_inset

 l'équation linéaire de matrices 
\begin_inset Formula $AX=B$
\end_inset

 dans 
\begin_inset Formula $\reel^{N}$
\end_inset

 sans avoir à calculer 
\begin_inset Formula $A^{-1}$
\end_inset

.
 En effet, trouver l'inverse de 
\begin_inset Formula $A$
\end_inset

 peut poser problèmes de par le temps de calcul lorsque 
\begin_inset Formula $N$
\end_inset

 devient très grand.
 Par exemple, pour une taille 
\begin_inset Formula $N=20$
\end_inset

, il faudrait 5 fois l'âge de l'univers (
\begin_inset Formula $5\times13,7\times10^{9}$
\end_inset

 années) pour calculer 
\begin_inset Formula $A^{-1}$
\end_inset

.
 Nous allons donc, à l'aide de plusieurs méthodes, tender de résoudre l'équation
 sans réaliser ce calcul, en décomposant le problème en sous-problèmes plus
 simples à résoudre.
 Nous procéderons à des optimisations graduelles d'une méthode à l'autre
 du coût en temps de calcul et en espace mémoire utilisé pour le calcul.
 On utilisera tout au long de ce rapport, les matrices 
\begin_inset Formula $A\in\reel^{N\times N}$
\end_inset

 et 
\begin_inset Formula $B,X\in\reel^{N}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Références
\end_layout

\begin_layout Subsection
Bibliographie
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "example-glossaries-url"
options "plain"

\end_inset


\end_layout

\begin_layout Subsection
Biographies
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Gauss.png
	scale 10

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Cholesky.png

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsubsection
Johann Carl Friedrich Gauss
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
Avant d'étudier la méthode de Gauss, il peut être pertinent d'établir une
 courte biographie de son auteur.
 Surnommé 
\begin_inset Quotes eld
\end_inset

prince des mathématiques
\begin_inset Quotes erd
\end_inset

 par ses pairs, ce mathématicien, né le 30 avril 1777, a contribué de bien
 des manières à développer non seulement les mathématiques mais également
 les méthodes en astrophysique et en électromagnétisme.
 Johann Carl Friedrich Gauss a pu se pencher sur des problèmes dits classiques
 (depuis l'antiquité) en adoptant des méthodes et raisonnements modernes.
 Il démontre alors le théorème fondamental de l'algèbre que l'on connaît
 aujourd'hui sous le nom du théorème de d'Alembert-Gauss, il dédie également
 un ouvrage à la théorie des nombres contenant plusieurs démonstrations
 qui révolutionnent l'arithmétique, on lui doit en partie la forme actuelle
 des nombres complexes.
 En astrophysique, il met au point la méthodes des moindres carrés permettant
 de minimiser les incertitudes dues aux mesures ce qui lui permet de déterminer
 exactement la position de Ceres, une planète naine du système solaire.
 Avec la contribution de Wilhem Weber, Gauss formule deux théorèmes essentiels
 en électromagnétisme réfutant l'existence de monopôle magnétique et établissant
 une relation entre le flux d'un champ électrique sur une surface fermée
 et la charge électrique totale à l'intérieur de cette surface.
 Cette liste est loin de résumer tous ses travaux, dont une partie a été
 publiée après son décès le 23 février 1855, ces derniers sont très nombreux
 et ont servi de base de recherche pour d'autres mathématiciens et physiciens
 après lui.
 Il est donc intéressant d'étudier la solution apportée par Gauss et de
 l'appliquer à notre problématique.
 L'élimination de Gauss est expliquée ci-après.
\end_layout

\begin_layout Subsubsection
André-Louis Cholesky
\end_layout

\begin_layout Standard
André-Louis Cholesky, également appelé René Cholesky, est un polytechnicien
 français qui s'est engagé dans l'armée suite à sa formation.
 Au cours de sa carrière militaire, on lui assigne différentes missions
 qui l'emmènent à plusieurs endroits où il effectue notamment des travaux
 de triangulation.
 Il participe à la Première Guerre mondiale où il est blessé et il meurt
 le 31 août 1918 des suites de ses blessures.
 Cependant, on le connaît plus pour ses contributions aux mathématiques
 que pour sa carrière de militaire.
 En effet, il est l'auteur d'un manuscrit intitulé 
\begin_inset Quotes eld
\end_inset

Sur la résolution numérique des systèmes d'équations linéaires
\begin_inset Quotes erd
\end_inset

.
 Cette méthode est en fait une nouvelle approche de la méthode des moindres
 carrés et sera publiée 6 ans après sa mort.
\end_layout

\begin_layout Subsubsection
Jacobi
\end_layout

\begin_layout Standard
Charles Gustave Jacob Jacobi est un mathématicien allemand né le 10 décembre
 1804.
 Après avoir soutenu une thèse sur la théorie des fractions, il enseigne
 les mathématiques à l'université de Königsberg.
 En parallèle de sa fonction de professeur, il effectue des travaux de recherche
 en physique mathématique, en théorie des nombres et en analyse mathématique
 pour n'en citer que quelques uns.
 On lui doit notamment la théorie des déterminants et en particulier l'invention
 du déterminant d'une matrice (jacobienne).
 Il publie également un traité fondamental sur les fonctions elliptiques
 qui révolutionne la physique mathématique mais il dédie aussi un ouvrage
 aux équations différentielles.
 Malgré sa mort prématurée en 1851, à l'âge de 46 ans, ses travaux furent
 nombreux et on retrouve parmi eux une méthode de résolution de systèmes
 linéaires.
 Contrairement aux méthodes de Gauss, de Cholesky ou encore de factorisation
 LU qui sont des méthodes directes, la méthode de Jacobi est une méthode
 dite itérative.
 Il est alors pertinent de s'intéresser à cette méthode et de l'implémenter
 en C si l'on veut réaliser une comparaison entre les deux types de méthode.
\end_layout

\begin_layout Subsubsection
Philipp von Seidel
\end_layout

\begin_layout Standard
Philipp von Seidel est un mathématicien et physicien Allemand.
 Né le 24 octobre 1821, il étudie dans de nombreuses villes dû au travail
 de son père, puis suit des cours privés sous la tutelle de L.C.
 Schnürlein, ancien élève de Gauss, pendant un an.
 Il suit ensuite l’enseignement d’autres grands représentants de leur discipline
 tels que Dirichlet, Encke, Jacobi ou encore Neumann dans trois universités
 différentes.
 En 1846, Seidel obtient son doctorat grâce à sa thèse: “Sur la meilleure
 forme des miroirs dans un télescope", puis publie une autre thèse six mois
 plus tard sur un sujet entièrement différent: "Études sur la convergence
 et divergence des fractions continues”, ce qui lui permet de devenir professeur
 à l’université de Munich.
 Des problèmes de vue le forcent à prendre une retraite anticipée, et n’étant
 pas marié, ce sont sa sœur puis une veuve qui s’occupent de lui en fin
 de vie.
 Il meurt le 13 août 1896.
\end_layout

\begin_layout Standard
Seidel se concentre tout au long de sa carrière sur ses travaux en optique
 et en astronomie ainsi que sur l’analyse mathématique, et décompose les
 aberrations optiques du premier ordre en cinq équations, appelées “équations
 de Seidel”.
 Il applique la théorie des probabilités à l’astronomie, et l’utilise également
 pour étudier la fréquence de certaines maladies ou le climat.
 Il est particulièrement connu pour la méthode de Gauss-Seidel de résolution
 d’équation numérique, que nous décrirons dans ce rapport.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Travail préliminaire
\end_layout

\begin_layout Subsection
Type de données
\end_layout

\begin_layout Standard
Tout d'abord, en C comme dans la plupart des langages de programmation,
 il est impossible d'exprimer l'intégralité des réels, entiers, complexes
 ...
 car il faudrait disposer d'une mémoire infinie pour représenter une infinité
 de nombres.
 Comme nous utilisons des nombres réels pour les vecteurs et matrices, il
 faut choisir parmi les types signés flottant du C qui sont :
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Taille
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Portée
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Précision maximale
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bits / 4 octets
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1,2\cdot10^{-38}$
\end_inset

 à 
\begin_inset Formula $3,4\cdot10^{38}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 chiffre après la virgule
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64 bits / 8 octets
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2,3\cdot10^{-308}$
\end_inset

 à 
\begin_inset Formula $1,7\cdot10^{308}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15 chiffres après la virgule
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
long double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
80 bits / 10 octets
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $3,4\cdot10^{-4932}$
\end_inset

 à 
\begin_inset Formula $1,1\cdot10^{4932}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19 chiffres après la virgule
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Dans ce projet, le point qui nous intéresse le plus est celui de la performance
 de la résolution, cette dernière étant très exigeante en temps processeur.
 Ainsi, le choix du type est crucial.
 Au final, nous avons choisi le type 
\begin_inset Quotes eld
\end_inset

double
\begin_inset Quotes erd
\end_inset

 car il offre une précision et une portée amplement suffisante, sans compromettr
e les performances de nos algorithmes.
 En effet, contrairement au type 
\begin_inset Quotes fld
\end_inset

long double
\begin_inset Quotes frd
\end_inset

, le type 
\begin_inset Quotes fld
\end_inset

double
\begin_inset Quotes frd
\end_inset

 ne nécessite pas de temps processeur supplémentaire par rapport à un type
 
\begin_inset Quotes fld
\end_inset

float
\begin_inset Quotes frd
\end_inset

 sur les ordinateurs modernes, pour lesquels, les processeur possèdent des
 registres de calculs flottant de 64 bits / 8 octets.
 Il est à noter que cette considération aurait été différente il y a 10
 - 20 ans car les processeurs plus anciens possédaient seulement unités
 et registres de calcul flottant de 32 bits, 16 bits voir 8 bits (pour les
 plus anciens).
 Ainsi, il fallait des cycles d'horloges supplémentaires pour un calcul
 flottant sur 64 bits par rapport à un calcul flottant sur 32 bits.
 Idem dans le cas de calculateurs scientifiques qui possèdent généralement
 des unités de calculs et registres flottants de 128 bits (voir plus).
 De plus, bien que le type 
\begin_inset Quotes fld
\end_inset

double
\begin_inset Quotes frd
\end_inset

 occupe deux fois plus de mémoire que le type 
\begin_inset Quotes fld
\end_inset

float
\begin_inset Quotes frd
\end_inset

, ici l'impact sur la mémoire reste relativement limité comparé à la précision
 supplémentaire offerte.
\end_layout

\begin_layout Subsection
Structure des données
\end_layout

\begin_layout Standard
Ensuite, les concepts de matrice et de vecteur ne sont pas directement implément
és dans le langage C.
 Cependant, nous pouvons utiliser une liste simple de 
\begin_inset Quotes fld
\end_inset

double
\begin_inset Quotes frd
\end_inset

 pour les vecteurs et des listes de 
\begin_inset Quotes fld
\end_inset

double
\begin_inset Quotes frd
\end_inset

 imbriquées dans des listes (tableau à 2 dimension) pour les matrices.
 
\end_layout

\begin_layout Standard
Ainsi, pour l'allocation des vecteurs et des matrices, nous avons implémenté
 les fonctions suivantes :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

double *Allocation_Vecteur(int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Allocation d'un espace de mémoire de taille = Taille Vecteur * Taille
 du type (8 octets).
\end_layout

\begin_layout Plain Layout

    double * Vecteur = (double *)malloc(Taille * sizeof(double));
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    // Nettoyage du vecteur.
\end_layout

\begin_layout Plain Layout

    Nettoyage_Vecteur(Vecteur, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return Vecteur;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

double **Allocation_Matrice(int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Allocation de la première dimension
\end_layout

\begin_layout Plain Layout

    double **Matrice = (double **)malloc(Taille * sizeof(double));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Allocation de la deuxième dimension
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        Matrice[i] = Allocation_Vecteur(Taille);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Nettoyage de la matrice (remplissage par des 0)
\end_layout

\begin_layout Plain Layout

    Nettoyage_Matrice(Matrice, Taille);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    return Matrice;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ces fonctions appellent les fonctions 
\begin_inset Quotes eld
\end_inset

Nettoyage_Vecteur
\begin_inset Quotes erd
\end_inset

 et 
\begin_inset Quotes eld
\end_inset

Nettoyage_Matrice
\begin_inset Quotes erd
\end_inset

, qui vont remplir de 
\begin_inset Formula $0$
\end_inset

 les matrices et vecteurs.
 En effet, la mémoire alloué par le système n'est pas toujours 
\begin_inset Quotes fld
\end_inset

propre
\begin_inset Quotes frd
\end_inset

; elle peut contenir des valeurs aléatoires.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void Nettoyage_Vecteur(double *Vecteur, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Itère parmis les éléments du vecteur
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // Remplissage par des 0
\end_layout

\begin_layout Plain Layout

        Vecteur[i] = 0;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void Nettoyer_Matrice(double **A, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Itère parmis la première dimension
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // Nettoyage de la deuxième dimension
\end_layout

\begin_layout Plain Layout

        Nettoyage_Vecteur(A[i], Taille);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ensuite, afin de rendre l'affichage des vecteurs et matrices lisible, nous
 avons implémenté les fonctions suivantes :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void Afficher_Vecteur(double *Vecteur, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Saut de ligne.
\end_layout

\begin_layout Plain Layout

    printf("
\backslash
n");
\end_layout

\begin_layout Plain Layout

    // Itère parmis les éléments du vecteur.
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // Affichage de la valeur suivi d'un saut de ligne.
\end_layout

\begin_layout Plain Layout

        printf("%f
\backslash
n", Vecteur[i]);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void Afficher_Matrice(double **Matrice, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Itère parmis la première dimension de la matrice.
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // Retour à la ligne.
\end_layout

\begin_layout Plain Layout

        printf("
\backslash
n");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Itère parmis la deuxième dimension de la matrice.
\end_layout

\begin_layout Plain Layout

        for (int j = 0; j < Taille; j++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            // Affichage de la valeur avec un séparateur.
\end_layout

\begin_layout Plain Layout

            printf("| %f ", Matrice[i][j]);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        // Retour à la ligne.
\end_layout

\begin_layout Plain Layout

        printf("|
\backslash
n");
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Enfin, comme nous utilisons de l’allocation dynamique pour les vecteurs
 et matrices, la libération de la mémoire (dés-allocation) doit être faite
 manuellement :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Méthodes directes
\end_layout

\begin_layout Standard
On considère qu'une méthode de résolution de systèmes linéaires 
\begin_inset Formula $AX=B$
\end_inset

 est directe lorsque celle-ci permet d'aboutir à une solution, si cette
 dernière existe, au terme d'un nombre fini d'opérations élémentaires, c'est-à-d
ire les additions, soustractions, multiplications et divisions.
 Les solutions obtenues via ce type de méthodes sont exactes mais cela ne
 signifie qu'elles sont infaillibles.
 En effet, plus le nombre d'opérations à effectuer est important, plus le
 risque d'avoir des erreurs de calcul augmente.
 Généralement, ce nombre est proportionnel à la taille du système étudié.
 Il existe de nombreuses méthodes directes, nous en avons sélectionné quelques-u
nes que nous décrirons dans ce rapport.
 Nous commencerons par introduire deux algorithmes, un premier pour le cas
 des matrices triangulaires inférieures et un second pour les matrices triangula
ires supérieures.
 Nous pourrons ensuite nous intéresser à la méthode d'élimination de Gauss,
 à la factorisation LU ainsi qu'à la méthode de Cholesky.
\end_layout

\begin_layout Subsection
Méthode triangulaire inférieure
\end_layout

\begin_layout Subsubsection*
Principe
\end_layout

\begin_layout Standard
Pour cette première méthode, 
\begin_inset Formula $A$
\end_inset

 est une matrice triangulaire inférieure.
 On peut donc facilement trouver X en suivant un algorithme dit 
\begin_inset Quotes fld
\end_inset

de la descente
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Méthode
\end_layout

\begin_layout Standard
Soit 
\begin_inset Formula $N=3$
\end_inset

, on a donc : 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
AX=B
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Rightarrow\left(\begin{array}{ccc}
a_{11} & 0 & 0\\
a_{21} & a_{22} & 0\\
a_{31} & a_{32} & a_{33}
\end{array}\right)\left(\begin{array}{c}
x_{1}\\
x_{2}\\
x_{3}
\end{array}\right)=\text{\left(\begin{array}{c}
b_{1}\\
b_{2}\\
b_{3}
\end{array}\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Rightarrow\begin{pmatrix}a_{11}x_{1}\\
a_{21}x_{1}+a_{22}x_{2}\\
a_{31}x_{1}+a_{32}x_{2}+a_{33}x_{3}
\end{pmatrix}=\left(\begin{array}{c}
b_{1}\\
b_{2}\\
b_{3}
\end{array}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Rightarrow\begin{pmatrix}x_{1}\\
x_{2}\\
x_{3}
\end{pmatrix}=\begin{pmatrix}\frac{b_{1}}{a_{11}}\\
\frac{b_{2}}{a_{22}}-\frac{a_{21}}{a_{22}}x_{1}\\
\frac{b_{3}}{a_{33}}-\frac{a_{31}}{a_{33}}x_{1}-\frac{a_{32}}{a_{33}}x_{2}
\end{pmatrix}
\]

\end_inset


\end_layout

\begin_layout Standard
On en déduit alors une formule générale pour les coefficients de 
\begin_inset Formula $X$
\end_inset

 :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x_{i}=\frac{b_{i}-\sum_{j=1}^{i-1}a_{ij}x_{j}}{a_{ii}},i=1,\ldots,N.
\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Code
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

double *Sol_Inf(double **a, double *b, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Allocation du vecteur X.
\end_layout

\begin_layout Plain Layout

    double *x = Allocation_Vecteur(Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Calcul du premier terme de X.
\end_layout

\begin_layout Plain Layout

    x[0] = b[0] / a[0][0];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Itère parmis les lignes de la matrice.
\end_layout

\begin_layout Plain Layout

    for (int i = 1; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // Calcul de la somme des a[i][j] * x[j]
\end_layout

\begin_layout Plain Layout

        double Sum = 0;
\end_layout

\begin_layout Plain Layout

        for (int j = 0; j < i; j++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            Sum = Sum + a[i][j] * x[j];
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        // Calcul du terme X[i].
\end_layout

\begin_layout Plain Layout

        x[i] = (b[i] - Sum) / a[i][i];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return x;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exemple
\end_layout

\begin_layout Standard
Pour 
\begin_inset Formula $A=\begin{pmatrix}1 & 0 & 0\\
2 & 3 & 0\\
1 & 4 & -1
\end{pmatrix}$
\end_inset

 et 
\begin_inset Formula $B=\begin{pmatrix}1\\
8\\
10
\end{pmatrix}$
\end_inset

, l'algorithme nous retourne 
\begin_inset Formula $X=\begin{pmatrix}1\\
2\\
-1
\end{pmatrix}$
\end_inset

, ce qui est correct.
\end_layout

\begin_layout Subsubsection*
Conclusion
\end_layout

\begin_layout Standard
Ainsi, cet algorithme possède une complexité temporelle maximale quadratique
 
\begin_inset Formula $O\left(N²\right)$
\end_inset

 car nous avons deux boucles imbriquées les unes dans les autres qui dépendent
 de la taille 
\begin_inset Formula $N$
\end_inset

 de 
\begin_inset Formula $A,B$
\end_inset

 et 
\begin_inset Formula $X$
\end_inset

.
 
\end_layout

\begin_layout Subsection
Méthode triangulaire supérieure
\end_layout

\begin_layout Subsubsection*
Principe
\end_layout

\begin_layout Standard
Cette méthode est similaire à la précédente, mais 
\begin_inset Formula $A$
\end_inset

 est ici une matrice triangulaire supérieure.
 On va donc cette fois trouver 
\begin_inset Formula $X$
\end_inset

 en suivant un algorithme dit 
\begin_inset Quotes fld
\end_inset

de la remontée
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Méthode
\end_layout

\begin_layout Standard
Soit 
\begin_inset Formula $N=3$
\end_inset

, on a :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
AX=B
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Rightarrow\left(\begin{array}{ccc}
a_{11} & a_{12} & a_{13}\\
0 & a_{22} & a_{23}\\
0 & 0 & a_{33}
\end{array}\right)\left(\begin{array}{c}
x_{1}\\
x_{2}\\
x_{3}
\end{array}\right)=\text{\left(\begin{array}{c}
b_{1}\\
b_{2}\\
b_{3}
\end{array}\right)\ensuremath{\Leftrightarrow}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Rightarrow\left\{ \begin{array}{c}
a_{33}x_{3}=b_{3}\\
a_{22}x_{2}+a_{23}x_{3}=b_{2}\\
a_{11}x_{1}+a_{12}x_{2}+a_{13}x_{3}=b_{1}
\end{array}\right.
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Rightarrow\begin{pmatrix}x_{1}\\
x_{2}\\
x_{3}
\end{pmatrix}=\begin{pmatrix}\frac{b_{1}}{a_{11}}-\frac{a_{12}}{a_{11}}x_{2}-\frac{a_{13}}{a_{11}}x_{3}\\
\frac{b_{2}}{a_{22}}-\frac{a_{23}}{a_{22}}x_{3}\\
\frac{b_{3}}{a_{33}}
\end{pmatrix}=\begin{pmatrix}\frac{b_{1}}{a_{11}}\\
\frac{b_{2}}{a_{22}}-\frac{a_{21}}{a_{22}}x_{1}\\
\frac{b_{3}-\sum_{k=1}^{2}a_{3k}x_{k}}{a_{33}}
\end{pmatrix}
\]

\end_inset


\end_layout

\begin_layout Standard
On en déduit alors une formule générale pour les coefficients de 
\begin_inset Formula $X$
\end_inset

 :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x_{i}=\frac{b_{i}-\sum_{j=i+1}^{N}a_{ij}x_{j}}{a_{ii}},i=N,\ldots,1
\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Code
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Ecrire algorithme ici
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exemple
\end_layout

\begin_layout Standard
Ainsi, pour 
\begin_inset Formula $A=\begin{pmatrix}1 & 2 & 3\\
0 & 4 & 8\\
0 & 0 & 5
\end{pmatrix}$
\end_inset

 et 
\begin_inset Formula $B=\begin{pmatrix}6\\
16\\
15
\end{pmatrix}$
\end_inset

, l'algorithme nous retourne 
\begin_inset Formula $X=\begin{pmatrix}1\\
-2\\
3
\end{pmatrix}$
\end_inset

, ce qui est correct.
\end_layout

\begin_layout Subsubsection*
Conclusion
\end_layout

\begin_layout Standard
De la même manière que le précédent, cet algorithme possède une complexité
 quadratique (
\begin_inset Formula $O\left(N^{2}\right)$
\end_inset

).
\end_layout

\begin_layout Subsection
Élimination de Gauss
\end_layout

\begin_layout Subsubsection*
Introduction
\end_layout

\begin_layout Standard
On veut maintenant résoudre l'équation 
\begin_inset Formula $AX=B$
\end_inset

 lorsque 
\begin_inset Formula $A$
\end_inset

 est une matrice carrée quelconque.
 Nous allons utiliser la méthode de l'élimination Gauss pour transformer
 l'expression 
\begin_inset Formula $AX=B$
\end_inset

 en 
\begin_inset Formula $UX=e$
\end_inset

 avec 
\begin_inset Formula $U\in\reel^{N\times N}$
\end_inset

, une matrice triangulaire supérieure.
 Ainsi, il ne restera plus qu'à résoudre 
\begin_inset Formula $UX=e$
\end_inset

 avec la fonction 
\begin_inset Quotes fld
\end_inset

Sol_Sup
\begin_inset Quotes frd
\end_inset

 pour obtenir 
\begin_inset Formula $X$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection*
Méthode
\end_layout

\begin_layout Standard
Soit 
\begin_inset Formula $N=3$
\end_inset

, on a :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Rightarrow\underbrace{\begin{pmatrix}3 & 1 & 2\\
3 & 2 & 6\\
6 & 1 & 1
\end{pmatrix}}_{A}\underbrace{\begin{pmatrix}x_{1}\\
x_{2}\\
x_{3}
\end{pmatrix}}_{X}=\underbrace{\begin{pmatrix}2\\
1\\
4
\end{pmatrix}}_{B}\Leftrightarrow\underbrace{\begin{pmatrix}a & b & c\\
0 & d & f\\
0 & 0 & g
\end{pmatrix}}_{U}\underbrace{\begin{pmatrix}x_{1}\\
x_{2}\\
x_{3}
\end{pmatrix}}_{X}=\underbrace{\begin{pmatrix}e_{1}\\
e_{2}\\
e_{3}
\end{pmatrix}}_{e}
\]

\end_inset


\end_layout

\begin_layout Standard
On a donc :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\begin{array}{c}
(1)\\
(2)\\
(3)
\end{array}\begin{pmatrix}3x_{1}+x_{2}+2x_{3}\\
3x_{1}+2x_{2}+6x_{3}\\
6x_{1}+x_{2}-x_{3}
\end{pmatrix}=\begin{pmatrix}2\\
1\\
4
\end{pmatrix}\Leftrightarrow\begin{pmatrix}ax_{1}+bx_{2}+cx_{3}\\
dx_{2}+fx_{3}\\
gx_{3}
\end{pmatrix}=\begin{pmatrix}e_{1}\\
e_{2}\\
e_{3}
\end{pmatrix}
\]

\end_inset


\end_layout

\begin_layout Standard
On va maintenant éliminer 
\begin_inset Formula $x_{1}$
\end_inset

 des équations 
\begin_inset Formula $(2)$
\end_inset

 et 
\begin_inset Formula $(3)$
\end_inset

 en utilisant 
\begin_inset Formula $(1)$
\end_inset

 :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\begin{array}{c}
(1)\\
(2')\\
(3')
\end{array}\begin{pmatrix}(1)\\
(2)-\frac{3}{3}(1)\\
(3)-\frac{3}{6}\left(1\right)
\end{pmatrix}=\begin{pmatrix}3x_{1}+x_{2}+2x_{3}\\
x_{2}+4x_{3}\\
-x_{2}-5x_{3}
\end{pmatrix}=\begin{pmatrix}2\\
-1\\
3
\end{pmatrix}
\]

\end_inset


\end_layout

\begin_layout Standard
Puis, on va éliminer 
\begin_inset Formula $x_{2}$
\end_inset

 de l'équation 
\begin_inset Formula $(3')$
\end_inset

 en utilisant 
\begin_inset Formula $(2')$
\end_inset

 :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\begin{array}{c}
(1)\\
(2')\\
(3'')
\end{array}\begin{pmatrix}(1)\\
(2)-\frac{3}{3}(1)\\
(3')-\frac{-1}{1}(2')
\end{pmatrix}=\begin{pmatrix}3x_{1}+x_{2}+2x_{3}\\
x_{2}+4x_{3}\\
-x_{3}
\end{pmatrix}=\begin{pmatrix}2\\
-1\\
2
\end{pmatrix}
\]

\end_inset


\end_layout

\begin_layout Standard
On remarque que pour éliminer un 
\begin_inset Formula $x_{i}$
\end_inset

 d'une équation 
\begin_inset Formula $\left(2\right)$
\end_inset

 en utilisant l'équation précédente (
\begin_inset Formula $\left(1\right)$
\end_inset

), on utilise une formule très simple : 
\begin_inset Formula $\left(2\right)-\frac{a_{1}}{a_{2}}\times\left(1\right)$
\end_inset

 avec 
\begin_inset Formula $a_{k}$
\end_inset

 le coefficient 
\begin_inset Formula $x_{i}$
\end_inset

 dans l'équation 
\begin_inset Formula $\left(k\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Si on factorise par 
\begin_inset Formula $X$
\end_inset

, on a donc bien 
\begin_inset Formula $U$
\end_inset

 une matrice triangulaire supérieure carrée :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\underbrace{\begin{pmatrix}3 & 1 & 2\\
0 & 1 & 4\\
0 & 0 & -1
\end{pmatrix}}_{U}\underbrace{\begin{pmatrix}x_{1}\\
x_{2}\\
x_{3}
\end{pmatrix}}_{X}=\underbrace{\begin{pmatrix}2\\
-1\\
2
\end{pmatrix}}_{e}
\]

\end_inset


\end_layout

\begin_layout Standard
Il ne reste plus qu'à utiliser 
\begin_inset Quotes fld
\end_inset

Sol_Sup
\begin_inset Quotes frd
\end_inset

 pour résoudre cette équation.
\end_layout

\begin_layout Subsubsection*
Code
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Code de mes fesses
\end_layout

\begin_layout Plain Layout

void KILL_ME()
\end_layout

\begin_layout Plain Layout

	
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exemple
\end_layout

\begin_layout Standard
Ainsi, pour 
\begin_inset Formula $A=\begin{pmatrix}1 & 2 & 3\\
5 & 2 & 1\\
3 & -1 & 1
\end{pmatrix}$
\end_inset

 et 
\begin_inset Formula $B=\begin{pmatrix}5\\
5\\
6
\end{pmatrix}$
\end_inset

, l'algorithme nous retourne 
\begin_inset Formula $X=\begin{pmatrix}1\\
-2\\
2
\end{pmatrix}$
\end_inset

, ce qui est correct.
\end_layout

\begin_layout Subsubsection*
Conclusion
\end_layout

\begin_layout Standard
Cette méthode est de complexité 
\begin_inset Formula $O\left(\frac{2N^{3}}{3}\right)$
\end_inset

, ce qui est relativement efficace.
 Cependant, elle demande de modifier entièrement 
\begin_inset Formula $A$
\end_inset

 et 
\begin_inset Formula $B$
\end_inset

.
 Lors de résolution de problèmes, il arrive que certaines données changent,
 ce qui modifierait 
\begin_inset Formula $A$
\end_inset

 mais surtout 
\begin_inset Formula $B$
\end_inset

.
 Il faudrait donc recalculer entièrement l’équation 
\begin_inset Formula $UX=e$
\end_inset

 puis la solution 
\begin_inset Formula $X$
\end_inset

 à chaque modification, ce qui est coûteux en temps de calcul.
\end_layout

\begin_layout Subsection
Factorisation 
\begin_inset Quotes eld
\end_inset

LU
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsubsection*
Principe
\end_layout

\begin_layout Standard
Afin d'éviter de recalculer 
\begin_inset Formula $U$
\end_inset

 et 
\begin_inset Formula $e$
\end_inset

 lorsque 
\begin_inset Formula $B$
\end_inset

 change, on factorise 
\begin_inset Formula $A$
\end_inset

 en 
\begin_inset Formula $LU$
\end_inset

, où 
\begin_inset Formula $L\in\reel^{N\times N}$
\end_inset

, une matrice triangulaire supérieure et 
\begin_inset Formula $U\in\reel^{N\times N}$
\end_inset

, une matrice triangulaire inférieure.
 Cette opération sera réalisée par la fonction 
\begin_inset Quotes fld
\end_inset

LU
\begin_inset Quotes frd
\end_inset

.
 On a donc 
\begin_inset Formula $LUX=B$
\end_inset

.
 On peut maintenant passer à la résolution qui va se faire en deux étapes
 :
\end_layout

\begin_layout Itemize
Tout d'abord, nous allons poser 
\begin_inset Formula $Y=UX$
\end_inset

.
 Ce qui donne : 
\begin_inset Formula $LY=B$
\end_inset

.
 
\begin_inset Formula $L$
\end_inset

 étant une matrice triangulaire supérieure carrée, il suffit d'utiliser
 la fonction 
\begin_inset Quotes fld
\end_inset

Sol_Sup
\begin_inset Quotes frd
\end_inset

 afin d'obtenir 
\begin_inset Formula $Y$
\end_inset

.
\end_layout

\begin_layout Itemize
Enfin, comme 
\begin_inset Formula $UX=Y$
\end_inset

 avec 
\begin_inset Formula $U$
\end_inset

 une matrice inférieure carrée, on peut utiliser 
\begin_inset Quotes fld
\end_inset

Sol_Inf
\begin_inset Quotes frd
\end_inset

 pour obtenir 
\begin_inset Formula $X$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Méthode
\end_layout

\begin_layout Standard
Pour faciliter les calculs, on décide que la diagonale de 
\begin_inset Formula $L$
\end_inset

 sera composée de 
\begin_inset Formula $1$
\end_inset

.
 On utilise ensuite l'élimination de Gauss pour calculer 
\begin_inset Formula $L$
\end_inset

, mais sans modifier la matrice 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Standard
<A finir !!!!!!!>
\end_layout

\begin_layout Subsubsection*
Code
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void LU(double **L, double **A, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    Nettoyer_Matrice(L, Taille, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Rempli les 1 en diagonale
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        L[i][i] = 1;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Calcule L et U
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille - 1; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        for (int k = i + 1; k < Taille; k++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            double C = A[k][i] / A[i][i];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            L[k][i] = C;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            for (int j = 0; j < Taille; j++)
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

                A[k][j] = A[k][j] - (C * A[i][j]);
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exemple
\end_layout

\begin_layout Standard
Pour 
\begin_inset Formula $A=\begin{pmatrix}3 & 1 & 2\\
3 & 2 & 6\\
6 & 1 & -1
\end{pmatrix}$
\end_inset

, l'algorithme nous retourne 
\begin_inset Formula $L=\begin{pmatrix}1 & 0 & 0\\
5 & 1 & 0\\
3 & 0,875 & 1
\end{pmatrix}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Puis, pour 
\begin_inset Formula $B=\begin{pmatrix}6\\
16\\
15
\end{pmatrix}$
\end_inset

 et 
\begin_inset Formula $L$
\end_inset

, 
\begin_inset Quotes fld
\end_inset

Sol_Sup
\begin_inset Quotes frd
\end_inset

 retourne 
\begin_inset Formula $Y=\begin{pmatrix}5\\
-20\\
8,5
\end{pmatrix}$
\end_inset

, ce qui est correct.
\end_layout

\begin_layout Standard
Enfin, pour 
\begin_inset Formula $U$
\end_inset

 et 
\begin_inset Formula $Y$
\end_inset

, 
\begin_inset Quotes fld
\end_inset

Sol_Inf
\begin_inset Quotes frd
\end_inset

 retourne 
\begin_inset Formula $X=\begin{pmatrix}1\\
-1\\
2
\end{pmatrix}$
\end_inset

, ce qui est correct.
\end_layout

\begin_layout Subsubsection*
Conclusion
\end_layout

\begin_layout Standard
Cette fonction est de complexité temporelle 
\begin_inset Formula $O\left(\frac{N^{3}}{6}\right)$
\end_inset

 
\end_layout

\begin_layout Standard
.
 
\end_layout

\begin_layout Standard
Cependant, dans le cas où 
\begin_inset Formula $A$
\end_inset

 est symétrique, il est possible de procéder à d'autres optimisations et
 diminuer le temps de calcul.
\end_layout

\begin_layout Subsection
Factorisation de Cholesky
\end_layout

\begin_layout Subsubsection*
Principe
\end_layout

\begin_layout Standard
Cette nouvelle méthode nous permet d’optimiser encore plus le code dans
 le cas où 
\begin_inset Formula $A$
\end_inset

 est symétrique (
\begin_inset Formula $A=A^{T}$
\end_inset

) et définie positive (positive et inversible 
\begin_inset Formula $\Leftrightarrow\left\langle AY,Y\right\rangle >0,\forall Y\in\reel^{N}\setminus\left\{ \overrightarrow{0}\right\} $
\end_inset

).
 On peut alors exprimer 
\begin_inset Formula $A$
\end_inset

 en fonction de 
\begin_inset Formula $L\in\reel^{N\times N}$
\end_inset

 une matrice triangulaire inférieure dont la diagonale est strictement positive
 : 
\begin_inset Formula $A=L\cdot L^{T}$
\end_inset

.
\end_layout

\begin_layout Standard
Si on remplace dans notre expression initiale, on a : 
\begin_inset Formula $AX=B\Leftrightarrow L\cdot L^{T}\cdot X=B$
\end_inset


\end_layout

\begin_layout Standard
On peut passer maintenant passer à la résolution.
 De manière similaire à la méthode 
\begin_inset Quotes fld
\end_inset

LU
\begin_inset Quotes frd
\end_inset

, nous allons procéder en deux étapes.
\end_layout

\begin_layout Itemize
Tout d'abord, la résolution de l'expression 
\begin_inset Formula $LY=B$
\end_inset

 où 
\begin_inset Formula $Y=L^{T}X$
\end_inset

 avec la fonction 
\begin_inset Quotes fld
\end_inset

Sol_Inf
\begin_inset Quotes frd
\end_inset

.
 
\begin_inset Formula $L$
\end_inset

 étant une matrice triangulaire inférieure carrée.
\end_layout

\begin_layout Itemize
Enfin, la résolution de l'expression 
\begin_inset Formula $L^{T}X=Y$
\end_inset

 avec la fonction 
\begin_inset Quotes fld
\end_inset

Sol_Sup
\begin_inset Quotes frd
\end_inset

.
 
\begin_inset Formula $L^{T}$
\end_inset

 étant également une matrice triangulaire inférieure carrée.
\end_layout

\begin_layout Subsubsection*
Méthode
\end_layout

\begin_layout Standard
Soit 
\begin_inset Formula $N=4$
\end_inset

, 
\begin_inset Formula $L$
\end_inset

 une matrice de taille 
\begin_inset Formula $N*N$
\end_inset

 : 
\end_layout

\begin_layout Standard
On créer une matrice 
\begin_inset Formula $L$
\end_inset

 tel que 
\begin_inset Formula $L\cdot L^{T}=A$
\end_inset

, on a :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\underbrace{\begin{pmatrix}l_{11} & 0 & 0 & 0\\
l_{21} & l_{22} & 0 & 0\\
l_{31} & l_{32} & l_{33} & 0\\
l_{41} & l_{42} & l_{43} & l_{44}
\end{pmatrix}}_{L}\underbrace{\begin{pmatrix}l_{11} & l_{21} & l_{31} & l_{41}\\
0 & l_{22} & l_{32} & l_{42}\\
0 & 0 & l_{33} & l_{43}\\
0 & 0 & 0 & l_{44}
\end{pmatrix}}_{L^{T}}=\underbrace{\begin{pmatrix}a_{11} & a_{12} & a_{13} & a_{14}\\
a_{21} & a_{22} & a_{23} & a_{24}\\
a_{31} & a_{32} & a_{33} & a_{34}\\
a_{41} & a_{42} & a_{43} & a_{44}
\end{pmatrix}}_{A}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Leftrightarrow\begin{pmatrix}l_{11}^{2} & l_{11}l_{21} & l_{11}l_{31} & l_{11}l_{41}\\
l_{21}l_{11} & l_{21}^{2}+l_{22}^{2} & l_{21}l_{31}+l_{22}l_{32} & l_{21}l_{41}+l_{22}l_{42}\\
l_{31}l_{11} & l_{31}l_{21}+l_{32}l_{22} & l_{31}^{2}+l_{32}^{2}+l_{33}^{2} & l_{31}l_{41}+l_{32}l_{42}+l_{33}l_{43}\\
l_{41}l_{11} & l_{41}l_{21}+l_{42}l_{22} & l_{41}l_{31}+l_{42}l_{32}+l_{43}l_{33} & l_{41}^{2}+l_{42}^{2}+l_{43}^{2}+l_{44}^{2}
\end{pmatrix}=\begin{pmatrix}a_{11} & a_{12} & a_{13} & a_{14}\\
a_{21} & a_{22} & a_{23} & a_{24}\\
a_{31} & a_{32} & a_{33} & a_{34}\\
a_{41} & a_{42} & a_{43} & a_{44}
\end{pmatrix}
\]

\end_inset


\end_layout

\begin_layout Standard
On a donc pour les termes en diagonale :
\end_layout

\begin_layout Itemize
\begin_inset Formula $l_{11}^{2}=a_{11}\Rightarrow l_{11}=\sqrt{a_{11}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $l_{21}^{2}+l_{22}^{2}=a_{22}\Rightarrow l_{22}=\sqrt{a_{22}-l_{21}^{2}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $l_{31}^{2}+l_{32}^{2}+l_{33}^{2}=a_{33}\Rightarrow l_{33}=\sqrt{a_{33}-l_{31}^{2}-l_{32}^{2}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $l_{41}^{2}+l_{42}^{2}+l_{43}^{2}+l_{44}^{2}=a_{44}\Rightarrow l_{44}=\sqrt{a_{44}-l_{41}^{2}-l_{42}^{2}-l_{43}^{2}}$
\end_inset


\end_layout

\begin_layout Standard
On constate que : 
\begin_inset Formula $l_{ii}=\sqrt{a_{ii}-\sum_{k=1}^{i-1}l_{ik}^{2}}$
\end_inset

 
\end_layout

\begin_layout Standard
On a également pour les autres termes :
\end_layout

\begin_layout Itemize
\begin_inset Formula $l_{21}l_{11}=a_{21}\Rightarrow l_{21}=\frac{a_{21}}{l_{11}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $l_{31}l_{11}=a_{31}\Rightarrow l_{31}=\frac{a_{31}}{l_{11}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $l_{31}l_{11}=a_{41}\Rightarrow l_{41}=\frac{a_{31}}{l_{11}}$
\end_inset


\end_layout

\begin_layout Standard
On constate que 
\begin_inset Formula $l_{ij}=\frac{a_{ij}}{l_{jj}}-\sum_{k=1}^{j-1}l_{ik}l_{jk}$
\end_inset


\end_layout

\begin_layout Subsubsection*
Code
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Ecrire code
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exemple
\end_layout

\begin_layout Standard
Ainsi, pour 
\begin_inset Formula $A=\begin{pmatrix}1 & 1 & 1 & 1\\
1 & 5 & 5 & 5\\
1 & 5 & 14 & 14\\
1 & 5 & 14 & 15
\end{pmatrix}$
\end_inset

, l'algorithme nous retourne 
\begin_inset Formula $L=\begin{pmatrix}1 & 0 & 0 & 0\\
1 & 2 & 0 & 0\\
1 & 2 & 3 & 0\\
1 & 2 & 3 & 1
\end{pmatrix}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Puis, pour 
\begin_inset Formula $B=\begin{pmatrix}5\\
1\\
3\\
1
\end{pmatrix}$
\end_inset

 et 
\begin_inset Formula $L$
\end_inset

, 
\begin_inset Quotes fld
\end_inset

Sol_Inf
\begin_inset Quotes frd
\end_inset

 retourne 
\begin_inset Formula $Y=\begin{pmatrix}5\\
-20\\
8,5
\end{pmatrix}$
\end_inset

, ce qui est correct.
\end_layout

\begin_layout Standard
Enfin, pour 
\begin_inset Formula $A$
\end_inset

 et 
\begin_inset Formula $Y$
\end_inset

, 
\begin_inset Quotes fld
\end_inset

Sol_Inf
\begin_inset Quotes frd
\end_inset

 retourne 
\begin_inset Formula $X=\begin{pmatrix}1\\
-1\\
2
\end{pmatrix}$
\end_inset

, ce qui est correct.
\end_layout

\begin_layout Subsubsection*
Conclusion
\end_layout

\begin_layout Standard
Lors de la factorisation, on effectue 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Méthodes itératives
\end_layout

\begin_layout Standard
Les méthodes itératives sont une autre approche à la résolution de systèmes
 linéaires 
\begin_inset Formula $AX=B$
\end_inset

.
 Afin d'aboutir à une solution via ces méthodes, on part d'une approximation
 de solution que l'on considérera comme une ébauche et non comme notre résultat
 final, on peut par exemple l'obtenir à l'aide d'une méthode directe .
 On effectue ensuite des itérations qui établissent une suite de solutions
 intermédiaires qui se rapprochent de plus en plus de la solution finale.
 L'idée est donc de construire une suite de vecteurs intermédiaires 
\begin_inset Formula $X^{k}$
\end_inset

 qui converge vers 
\begin_inset Formula $X$
\end_inset

, solution du système.
 Procéder de cette manière permet de limiter la propagation d'erreurs et
 ainsi obtenir la solution la plus proche possible de la solution réelle.
 Nous avons sélectionné deux méthodes itératives à décrire, la méthode de
 Jacobi et la méthode de Gauss-Seidel.
 Même si nous n'avons pas eu l'occasion d'aborder en détails la méthode
 de Gauss-Seidel en cours, il nous semblait pertinent de tout de même l'inclure
 dans notre rapport afin d'avoir un élément supplémentaire de comparaison
 dans notre étude des différentes méthodes de résolutions de systèmes linéaires.
\end_layout

\begin_layout Subsection
Méthode de Jacobi
\end_layout

\begin_layout Subsubsection*
Principe
\end_layout

\begin_layout Standard
Soit 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $B,X\in\reel^{N}$
\end_inset

 et
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $A\in\reel^{N\times N}$
\end_inset

, on cherche toujours à résoudre l'équation 
\begin_inset Formula $AX=B$
\end_inset

.
\end_layout

\begin_layout Standard
On peut décomposer 
\begin_inset Formula $A$
\end_inset

 en 3 matrices tel que 
\begin_inset Formula $A=E+F+G$
\end_inset

 : 
\end_layout

\begin_layout Itemize
\begin_inset Formula $D$
\end_inset

 la matrice contenant la diagonale de 
\begin_inset Formula $A$
\end_inset

 : 
\begin_inset Formula $D=\begin{pmatrix}A_{11} & 0 & \cdots & 0\\
0 & \ddots & \ddots & \vdots\\
\vdots & \ddots & \ddots & 0\\
0 & \cdots & 0 & A_{nn}
\end{pmatrix}$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $E$
\end_inset

 la matrice contenant la partie inférieur de 
\begin_inset Formula $A$
\end_inset

 (sans sa diagonale) : 
\begin_inset Formula $E=\begin{pmatrix}0 & \cdots & \cdots & 0\\
A_{1j} & \ddots & \iddots & \vdots\\
\vdots & \ddots & \ddots & \vdots\\
A_{ij} & \cdots & A_{\left(i-1\right)j} & 0
\end{pmatrix}$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $F$
\end_inset

 la matrice contenant la partie supérieure de 
\begin_inset Formula $A$
\end_inset

 (sans la diagonale) : 
\begin_inset Formula $F=\begin{pmatrix}0 & A & \cdots & A_{ij}\\
\vdots & \ddots & \ddots & \vdots\\
\vdots & \iddots & \ddots & A\\
0 & \cdots & \cdots & 0
\end{pmatrix}$
\end_inset

e
\end_layout

\begin_layout Standard
L'équation initiale 
\begin_inset Formula $AX=B$
\end_inset

 devient alors : 
\begin_inset Formula $\left(E+D+F\right)X=B$
\end_inset

, ce qui donne
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Rightarrow DX=B-\left(E+F\right)X
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Rightarrow X=D^{-1}\left(B-\left[E+F\right]X\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Rightarrow\begin{cases}
X^{0} & k=0\\
X_{i}^{k+1}=D^{-1}\left(B-\left[E+F\right]X^{k}\right) & k=1,\ldots,N
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Si il y a convergence, 
\begin_inset Formula $X^{k+1}\approx X^{k}=X^{*}$
\end_inset


\end_layout

\begin_layout Subsubsection*
Méthode
\end_layout

\begin_layout Standard
Ainsi, pour un 
\begin_inset Formula $X_{i}^{k+1}$
\end_inset

 donné, on peut calculer 
\begin_inset Formula $X_{i}^{k+1}=\frac{B_{i}-\sum_{j=1,j\neq i}^{N}A_{ij}X_{j}^{k}}{A_{ii}}$
\end_inset

 pour 
\begin_inset Formula $i=1,\ldots,N$
\end_inset

.
\end_layout

\begin_layout Standard
A chaque itération, 
\begin_inset Formula $x_{k}$
\end_inset

 va converger vers 
\begin_inset Formula $x_{k+1}$
\end_inset

.
 On définit alors un 
\begin_inset Formula $\varepsilon$
\end_inset

 pour que la boucle continue d'itérer jusqu'à ce que : 
\begin_inset Formula $\left\Vert x_{k+1}-x_{k}\right\Vert _{2}=\sqrt{\sum_{n=0}^{N-1}\left(x_{k+1}\left[n\right]-x_{k}\left[n\right]\right)^{2}}\leqslant\varepsilon$
\end_inset

.
\end_layout

\begin_layout Standard
On définit également un nombre d'itération maximale pour limiter le nombre
 maximale d'itération si jamais l'algorithme n'atteint pas 
\begin_inset Formula $\varepsilon$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Code
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exemple
\end_layout

\begin_layout Standard
Pour 
\begin_inset Formula $A=\begin{pmatrix}4 & 1 & 1\\
1 & 3 & 1\\
2 & 0 & 5
\end{pmatrix}$
\end_inset

, 
\begin_inset Formula $B=\begin{pmatrix}1\\
1\\
1
\end{pmatrix}$
\end_inset

, 
\begin_inset Formula $\varepsilon=0,01$
\end_inset

 et un nombre d'itération maximale de 
\begin_inset Formula $10$
\end_inset

, l'algorithme retourne 
\begin_inset Formula $X=\begin{pmatrix}0,157701\\
0,236300\\
0,137924
\end{pmatrix}$
\end_inset

, ce qui semble correct car 
\begin_inset Formula $X\cdot A=\begin{pmatrix}1,005028\\
1,004525\\
1,005022
\end{pmatrix}\approx B=\begin{pmatrix}1\\
1\\
1
\end{pmatrix}$
\end_inset


\end_layout

\begin_layout Subsubsection*
Conclusion
\end_layout

\begin_layout Subsection
Méthode de Gauss-Seidel
\end_layout

\begin_layout Subsubsection*
Principe
\end_layout

\begin_layout Standard
Dans la méthode précédente, les coefficients du vecteur 
\begin_inset Formula $X^{k+1}$
\end_inset

 sont plus précis que ceux de 
\begin_inset Formula $X^{k}$
\end_inset

.
 Lorsque l'on calcule 
\begin_inset Formula $X^{k+1}$
\end_inset

, on calcule les coefficients de ce vecteur un par un : on peut donc utiliser
 les coefficients de ce vecteur déjà calculés plutôt que ceux du vecteur
 précédent.
 Une fois que la formule générale est trouvée, on suit les mêmes étapes
 de comparaison de la norme avec un epsilon choisi, et on a de la même façon
 
\begin_inset Formula $X$
\end_inset

 qui sera la limite d’une suite avec 
\begin_inset Formula $X^{0}$
\end_inset

 choisi.
\end_layout

\begin_layout Subsubsection*
Méthode
\end_layout

\begin_layout Standard
En calculant 
\begin_inset Formula $X_{i}^{k+1}$
\end_inset

 on ne connaît les coefficients de 
\begin_inset Formula $X^{k+1}$
\end_inset

 que jusqu'à 
\begin_inset Formula $i-1$
\end_inset

, on utilise ceux de 
\begin_inset Formula $X^{k}$
\end_inset

 pour le reste de la somme.
 On sépare donc la somme de la formule précédente en deux.
\end_layout

\begin_layout Subsubsection*
Code
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Code
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Conclusion
\end_layout

\begin_layout Standard
Cette méthode permet de gagner en précision par rapport à la précédente,
 bien qu’il faille encore choisir 
\begin_inset Formula $X^{0}$
\end_inset

 arbitrairement.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Code complet
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// - Importation des librairies nécéssaires.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <math.h>
\end_layout

\begin_layout Plain Layout

#include <malloc.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// - Gestion des vecteurs et matrices
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// - - Nettoyage
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Fonction qui nettoie un vecteur (remplissage par des 0).
\end_layout

\begin_layout Plain Layout

void Nettoyage_Vecteur(double *Vecteur, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Itère parmis les éléments du vecteur
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // Remplissage par des 0
\end_layout

\begin_layout Plain Layout

        Vecteur[i] = 0;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// - Fonction qui nettoie une matrice (remplissage par des 0).
\end_layout

\begin_layout Plain Layout

void Nettoyage_Matrice(double **A, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Itère parmis la première dimension
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // Nettoyage de la deuxième dimension
\end_layout

\begin_layout Plain Layout

        Nettoyage_Vecteur(A[i], Taille);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// - - Allocation
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Fonction qui alloue un vecteur de taille N.
\end_layout

\begin_layout Plain Layout

double *Allocation_Vecteur(int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Allocation d'un espace de mémoire de taille = Taille Vecteur * Taille
 du type (8 octets).
\end_layout

\begin_layout Plain Layout

    double *Vecteur = (double *)malloc(Taille * sizeof(double));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Nettoyage du vecteur.
\end_layout

\begin_layout Plain Layout

    Nettoyage_Vecteur(Vecteur, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return Vecteur;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Fonction qui alloue une matrice carrée de taille N * M
\end_layout

\begin_layout Plain Layout

double **Allocation_Matrice(int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Allocation de la première dimension
\end_layout

\begin_layout Plain Layout

    double **Matrice = (double **)malloc(Taille * sizeof(double));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Allocation de la deuxième dimension
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        Matrice[i] = Allocation_Vecteur(Taille);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return Matrice;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// - - Désallocation
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Fonction qui désalloue un vecteur de taille N.
\end_layout

\begin_layout Plain Layout

void Desallocation_Vecteur(double *Vecteur)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    free(Vecteur);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Fonction qui désalloue une matrice carrée de taille N.
\end_layout

\begin_layout Plain Layout

void Desallocation_Matrice(double **Matrice, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        Desallocation_Vecteur(Matrice[i]);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// - - Affichage
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Fonction qui affiche un vecteur de taille N.
\end_layout

\begin_layout Plain Layout

void Afficher_Vecteur(double *Vecteur, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Itère parmis les éléments du vecteur.
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // Affichage de la valeur suivi d'un saut de ligne.
\end_layout

\begin_layout Plain Layout

        printf("%f
\backslash
n", Vecteur[i]);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Fonction qui affiche une matrice carrée de taille N.
\end_layout

\begin_layout Plain Layout

void Afficher_Matrice(double **Matrice, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Itère parmis la première dimension de la matrice.
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Itère parmis la deuxième dimension de la matrice.
\end_layout

\begin_layout Plain Layout

        for (int j = 0; j < Taille; j++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            // Affichage de la valeur avec un séparateur.
\end_layout

\begin_layout Plain Layout

            printf("| %f ", Matrice[i][j]);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        // Retour à la ligne.
\end_layout

\begin_layout Plain Layout

        printf("|
\backslash
n");
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// - Méthodes directes de résolution.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// - - Resolution de matrices triangulaires carrées
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Fonction qui résoud AX = B avec A une matrice triangulaire inférieure
 carrée et B un vecteur (algorithme de la redescente).
\end_layout

\begin_layout Plain Layout

double *Sol_Inf(double **A, double *B, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Allocation du vecteur X.
\end_layout

\begin_layout Plain Layout

    double *X = Allocation_Vecteur(Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Calcul du premier terme de X.
\end_layout

\begin_layout Plain Layout

    X[0] = B[0] / A[0][0];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Itère parmis les lignes de la matrice.
\end_layout

\begin_layout Plain Layout

    for (int i = 1; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // Calcul de la somme des a[i][j] * x[j]
\end_layout

\begin_layout Plain Layout

        double Sum = 0;
\end_layout

\begin_layout Plain Layout

        for (int j = 0; j < i; j++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            Sum = Sum + A[i][j] * X[j];
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        // Calcul du terme X[i].
\end_layout

\begin_layout Plain Layout

        X[i] = (B[i] - Sum) / A[i][i];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return X;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Fonction qui résoud AX = B avec A une matrice triangulaire supérieure
 carrée et B un vecteur (algorithme de la remontée).
\end_layout

\begin_layout Plain Layout

double *Sol_Sup(double **A, double *B, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Allocation du vecteur X.
\end_layout

\begin_layout Plain Layout

    double *X = Allocation_Vecteur(Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Calcul du dernier terme de X (terme initial).
\end_layout

\begin_layout Plain Layout

    X[Taille - 1] = B[Taille - 1] / A[Taille - 1][Taille - 1];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Itère parmis les lignes de la matrice.
\end_layout

\begin_layout Plain Layout

    for (int i = Taille - 2; i >= 0; i--)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // Calcul de la somme des a[i][j] * x[j]
\end_layout

\begin_layout Plain Layout

        double Sum = 0;
\end_layout

\begin_layout Plain Layout

        for (int j = i + 1; j < Taille; j++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            Sum += A[i][j] * X[j];
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        X[i] = (B[i] - Sum) / A[i][i];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return X;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// - - Elimination de Gauss
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Fonction qui effectue l'élimination de Gauss pour transformer A en U,
 une matrice triangulaire supérieure carrée (algorithme de Gauss).
\end_layout

\begin_layout Plain Layout

void Gauss(double **A, double *B, double **U, double *e, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille - 1; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        for (int k = i + 1; k < Taille; k++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            double C = A[k][i] / A[i][i];
\end_layout

\begin_layout Plain Layout

            for (int j = 0; j < Taille; j++)
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

                U[k][j] = A[k][j] - (C * A[i][j]);
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            e[k] = B[k] - (C * B[i]);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// - - Factorisation LU
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Fonction qui effectue la factorisation LU pour transformer A en L et
 U, deux matrices triangulaires carrées inférieures et supérieures (algorithme
 de LU).
\end_layout

\begin_layout Plain Layout

void LU(double **L, double **A, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    Nettoyage_Matrice(L, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Rempli les 1 en diagonale
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        L[i][i] = 1;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Calcule L et U
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille - 1; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        for (int k = i + 1; k < Taille; k++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            double C = A[k][i] / A[i][i];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            L[k][i] = C;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            for (int j = 0; j < Taille; j++)
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

                A[k][j] = A[k][j] - (C * A[i][j]);
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// - - Factorisation de Cholesky
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Fonction qui transforme A en L*L^T.
 Renvoi L.
\end_layout

\begin_layout Plain Layout

double **Cholesky(double **A, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Allocation de la matrice L.
\end_layout

\begin_layout Plain Layout

    double **L = Allocation_Matrice(Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Itère parmis les lignes de la matrice.
\end_layout

\begin_layout Plain Layout

    for (int j = 0; j < Taille; j++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        double Sum = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // - Calcul de la somme.
\end_layout

\begin_layout Plain Layout

        for (int k = 0; k < j; k++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            Sum += L[j][k] * L[j][k];
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // - Calcul des termes de la diagonale de L.
\end_layout

\begin_layout Plain Layout

        L[j][j] = sqrt(A[j][j] - Sum);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // - Calcul des termes pour i = j+1 à N.
\end_layout

\begin_layout Plain Layout

        for (int i = j + 1; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            Sum = 0;
\end_layout

\begin_layout Plain Layout

            for (int k = 0; k < j; k++)
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                Sum += L[i][k] * L[j][k];
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            L[i][j] = (A[i][j] - Sum) / L[j][j];
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return L;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Fonction qui transpose une matrice carrée inférieure en matrice carrée
 supérieure.
\end_layout

\begin_layout Plain Layout

double **Transposer(double **Matrice, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // On itère parmis les colones.
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // On itère parmis les lignes.
\end_layout

\begin_layout Plain Layout

        for (int j = i + 1; j < Taille; j++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            // On inverse les termes (en cooordonnées) de la matrice.
\end_layout

\begin_layout Plain Layout

            Matrice[i][j] = Matrice[j][i];
\end_layout

\begin_layout Plain Layout

            //  On supprime les termes inférieurs.
\end_layout

\begin_layout Plain Layout

            Matrice[j][i] = 0;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return Matrice;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// - Méthodes itératives de résolution.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// - - Jacobi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

double *Jacobi(double **A, double *B, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    double *X_k = Allocation_Vecteur(Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Remplissage de X_k par des 1.
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        X_k[i] = 1;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    double *X_k_1 = Allocation_Vecteur(Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    double Norme;
\end_layout

\begin_layout Plain Layout

    int it = 0;
\end_layout

\begin_layout Plain Layout

    int it_max = 10;
\end_layout

\begin_layout Plain Layout

    double Epsilon = 0.001;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    do
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        printf("it = %d", it);
\end_layout

\begin_layout Plain Layout

        // - Calcul de X_k_1.
\end_layout

\begin_layout Plain Layout

        for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            // - Calcul de la somme des a[i][j] * x_k[j].
\end_layout

\begin_layout Plain Layout

            double Somme = 0;
\end_layout

\begin_layout Plain Layout

            for (int j = 0; j < Taille; j++)
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

                if (i != j)
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                    Somme += A[i][j] * X_k[j];
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            X_k_1[i] = (B[i] - Somme) / A[i][i];
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // - Calcul de la norme.
\end_layout

\begin_layout Plain Layout

        Norme = 0;
\end_layout

\begin_layout Plain Layout

        for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            Norme += (X_k_1[i] - X_k[i]) * (X_k_1[i] - X_k[i]);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        Norme = sqrt(Norme);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // - On remplace X_k par X_k_1.
\end_layout

\begin_layout Plain Layout

        for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            X_k[i] = X_k_1[i];
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        it++;
\end_layout

\begin_layout Plain Layout

    } while ((Norme > Epsilon) && (it < it_max));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return X_k_1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// - - Gauss-Seidel
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

double *Gauss_Seidel(double **A, double *B, int Taille)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // - Allocation des vecteurs.
\end_layout

\begin_layout Plain Layout

    double *X_k = Allocation_Vecteur(Taille);
\end_layout

\begin_layout Plain Layout

    double *X_k_1 = Allocation_Vecteur(Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // - Remplissage de X_k par des 1.
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        X_k[i] = 1;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    double Norme;
\end_layout

\begin_layout Plain Layout

    int it = 0;
\end_layout

\begin_layout Plain Layout

    int it_max = 10;
\end_layout

\begin_layout Plain Layout

    double Epsilon = 0.001;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    do
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // - Calcul de X_k_1.
\end_layout

\begin_layout Plain Layout

        for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            // - Calcul de la somme des A[i][j] * X_k_1[j].
\end_layout

\begin_layout Plain Layout

            double Somme = 0;
\end_layout

\begin_layout Plain Layout

            for (int j = 0; j < i; j++)
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

                Somme += A[i][j] * X_k_1[j];
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            // - Calcul de la somme des a[i][j] * x_k[j].
\end_layout

\begin_layout Plain Layout

            for (int j = i + 1; j < Taille; j++)
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

                Somme += A[i][j] * X_k[j];
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            X_k_1[i] = (B[i] - Somme) / A[i][i];
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // - Calcul de la norme entre X_k_1 et X_k.
\end_layout

\begin_layout Plain Layout

        Norme = 0;
\end_layout

\begin_layout Plain Layout

        for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            Norme += (X_k_1[i] - X_k[i]) * (X_k_1[i] - X_k[i]);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        Norme = sqrt(Norme);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // - On remplace X_k par X_k_1.
\end_layout

\begin_layout Plain Layout

        for (int i = 0; i < Taille; i++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            X_k[i] = X_k_1[i];
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        it++;
\end_layout

\begin_layout Plain Layout

    } while ((Norme > Epsilon) && (it < it_max));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return X_k_1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// - Fonction principale.
\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Les différentes parties sont mises entre accolades afin que les variables
 aients une portée locale (propres à chaques parties).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // - Méthodes directes
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // - - Méthode triangulaire inférieure.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // Définition de la taille.
\end_layout

\begin_layout Plain Layout

        int Taille = 3;
\end_layout

\begin_layout Plain Layout

        // Allocation des matrices et vecteurs.
\end_layout

\begin_layout Plain Layout

        double **A = Allocation_Matrice(Taille);
\end_layout

\begin_layout Plain Layout

        double *B = Allocation_Vecteur(Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Remplissage des matrices et vecteurs.
\end_layout

\begin_layout Plain Layout

        A[0][0] = 1;
\end_layout

\begin_layout Plain Layout

        A[0][1] = 0;
\end_layout

\begin_layout Plain Layout

        A[0][2] = 0;
\end_layout

\begin_layout Plain Layout

        A[1][0] = 2;
\end_layout

\begin_layout Plain Layout

        A[1][1] = 3;
\end_layout

\begin_layout Plain Layout

        A[1][2] = 0;
\end_layout

\begin_layout Plain Layout

        A[2][0] = 1;
\end_layout

\begin_layout Plain Layout

        A[2][1] = 4;
\end_layout

\begin_layout Plain Layout

        A[2][2] = -1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        B[0] = 1;
\end_layout

\begin_layout Plain Layout

        B[1] = 8;
\end_layout

\begin_layout Plain Layout

        B[2] = 10;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        double *X = Sol_Inf(A, B, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        printf("La solution X de l'équation AX = B avec la méthode triangulaire
 inférieure est :
\backslash
n");
\end_layout

\begin_layout Plain Layout

        Afficher_Vecteur(X, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Désallocation des matrices et vecteurs.
\end_layout

\begin_layout Plain Layout

        Desallocation_Matrice(A, Taille);
\end_layout

\begin_layout Plain Layout

        Desallocation_Vecteur(B);
\end_layout

\begin_layout Plain Layout

        Desallocation_Vecteur(X);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // - - Méthode triangulaire supérieure.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // Définition de la taille.
\end_layout

\begin_layout Plain Layout

        int Taille = 3;
\end_layout

\begin_layout Plain Layout

        // Allocation des matrices et vecteurs.
\end_layout

\begin_layout Plain Layout

        double **A = Allocation_Matrice(Taille);
\end_layout

\begin_layout Plain Layout

        double *B = Allocation_Vecteur(Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Remplissage des matrices et vecteurs.
\end_layout

\begin_layout Plain Layout

        A[0][0] = 1;
\end_layout

\begin_layout Plain Layout

        A[0][1] = 2;
\end_layout

\begin_layout Plain Layout

        A[0][2] = 3;
\end_layout

\begin_layout Plain Layout

        A[1][0] = 0;
\end_layout

\begin_layout Plain Layout

        A[1][1] = 4;
\end_layout

\begin_layout Plain Layout

        A[1][2] = 8;
\end_layout

\begin_layout Plain Layout

        A[2][0] = 0;
\end_layout

\begin_layout Plain Layout

        A[2][1] = 0;
\end_layout

\begin_layout Plain Layout

        A[2][2] = 5;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        B[0] = 6;
\end_layout

\begin_layout Plain Layout

        B[1] = 16;
\end_layout

\begin_layout Plain Layout

        B[2] = 15;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        double *X = Sol_Sup(A, B, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        printf("La solution X de AX = B d'après la méthode triangulaire
 supérieure est :
\backslash
n");
\end_layout

\begin_layout Plain Layout

        Afficher_Vecteur(X, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Désallocation des matrices et vecteurs.
\end_layout

\begin_layout Plain Layout

        Desallocation_Matrice(A, Taille);
\end_layout

\begin_layout Plain Layout

        Desallocation_Vecteur(B);
\end_layout

\begin_layout Plain Layout

        Desallocation_Vecteur(X);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // - - Elimination de Gauss.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // Définition de la taille.
\end_layout

\begin_layout Plain Layout

        int Taille = 3;
\end_layout

\begin_layout Plain Layout

        // Allocation des matrices et vecteurs.
\end_layout

\begin_layout Plain Layout

        double **A = Allocation_Matrice(Taille);
\end_layout

\begin_layout Plain Layout

        double *B = Allocation_Vecteur(Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Remplissage de A.
\end_layout

\begin_layout Plain Layout

        A[0][0] = 1;
\end_layout

\begin_layout Plain Layout

        A[0][1] = 2;
\end_layout

\begin_layout Plain Layout

        A[0][2] = 3;
\end_layout

\begin_layout Plain Layout

        A[1][0] = 5;
\end_layout

\begin_layout Plain Layout

        A[1][1] = 2;
\end_layout

\begin_layout Plain Layout

        A[1][2] = 1;
\end_layout

\begin_layout Plain Layout

        A[2][0] = 3;
\end_layout

\begin_layout Plain Layout

        A[2][1] = -1;
\end_layout

\begin_layout Plain Layout

        A[2][2] = 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Remplissage de B.
\end_layout

\begin_layout Plain Layout

        B[0] = 5;
\end_layout

\begin_layout Plain Layout

        B[1] = 5;
\end_layout

\begin_layout Plain Layout

        B[2] = 6;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Transformation de A en matrice triangulaire supérieure.
\end_layout

\begin_layout Plain Layout

        Gauss(A, B, A, B, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Résolution de l'équation.
\end_layout

\begin_layout Plain Layout

        double *X = Sol_Sup(A, B, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Affichage de X.
\end_layout

\begin_layout Plain Layout

        printf("La solution X de AX = B d'après la méthode de l'élimination
 de Gauss est :
\backslash
n");
\end_layout

\begin_layout Plain Layout

        Afficher_Vecteur(X, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Désallocation des matrices et vecteurs.
\end_layout

\begin_layout Plain Layout

        Desallocation_Matrice(A, Taille);
\end_layout

\begin_layout Plain Layout

        Desallocation_Vecteur(B);
\end_layout

\begin_layout Plain Layout

        Desallocation_Vecteur(X);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // - - Résolution par factorisation LU.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // Définition de la taille.
\end_layout

\begin_layout Plain Layout

        int Taille = 3;
\end_layout

\begin_layout Plain Layout

        // Allocation des matrices et vecteurs.
\end_layout

\begin_layout Plain Layout

        double **A = Allocation_Matrice(Taille);
\end_layout

\begin_layout Plain Layout

        double *B = Allocation_Vecteur(Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        A[0][0] = 1;
\end_layout

\begin_layout Plain Layout

        A[0][1] = 2;
\end_layout

\begin_layout Plain Layout

        A[0][2] = 3;
\end_layout

\begin_layout Plain Layout

        A[1][0] = 5;
\end_layout

\begin_layout Plain Layout

        A[1][1] = 2;
\end_layout

\begin_layout Plain Layout

        A[1][2] = 1;
\end_layout

\begin_layout Plain Layout

        A[2][0] = 3;
\end_layout

\begin_layout Plain Layout

        A[2][1] = -1;
\end_layout

\begin_layout Plain Layout

        A[2][2] = 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        B[0] = 5;
\end_layout

\begin_layout Plain Layout

        B[1] = 5;
\end_layout

\begin_layout Plain Layout

        B[2] = 6;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        double **L = Allocation_Matrice(Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Factorisation de A = LU.
\end_layout

\begin_layout Plain Layout

        LU(L, A, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Résolution de LY = B.
\end_layout

\begin_layout Plain Layout

        double *Y = Sol_Inf(L, B, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Résolution de UX = Y.
\end_layout

\begin_layout Plain Layout

        double *X = Sol_Sup(A, Y, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Affichage.
\end_layout

\begin_layout Plain Layout

        printf("La solution X de AX = B d'après la méthode de la factorisation
 LU est : 
\backslash
n");
\end_layout

\begin_layout Plain Layout

        Afficher_Vecteur(X, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Désallocation des matrices et vecteurs.
\end_layout

\begin_layout Plain Layout

        Desallocation_Matrice(L, Taille);
\end_layout

\begin_layout Plain Layout

        Desallocation_Matrice(A, Taille);
\end_layout

\begin_layout Plain Layout

        Desallocation_Vecteur(B);
\end_layout

\begin_layout Plain Layout

        Desallocation_Vecteur(Y);
\end_layout

\begin_layout Plain Layout

        Desallocation_Vecteur(X);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // - - Cholesky.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // Définition de la taille.
\end_layout

\begin_layout Plain Layout

        int Taille = 4;
\end_layout

\begin_layout Plain Layout

        // Allocation des matrices et vecteurs.
\end_layout

\begin_layout Plain Layout

        double **A = Allocation_Matrice(Taille);
\end_layout

\begin_layout Plain Layout

        double *B = Allocation_Vecteur(Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Remplissage de A.
\end_layout

\begin_layout Plain Layout

        A[0][0] = 1;
\end_layout

\begin_layout Plain Layout

        A[0][1] = 1;
\end_layout

\begin_layout Plain Layout

        A[0][2] = 1;
\end_layout

\begin_layout Plain Layout

        A[0][3] = 1;
\end_layout

\begin_layout Plain Layout

        A[1][0] = 1;
\end_layout

\begin_layout Plain Layout

        A[1][1] = 5;
\end_layout

\begin_layout Plain Layout

        A[1][2] = 5;
\end_layout

\begin_layout Plain Layout

        A[1][3] = 5;
\end_layout

\begin_layout Plain Layout

        A[2][0] = 1;
\end_layout

\begin_layout Plain Layout

        A[2][1] = 5;
\end_layout

\begin_layout Plain Layout

        A[2][2] = 14;
\end_layout

\begin_layout Plain Layout

        A[2][3] = 14;
\end_layout

\begin_layout Plain Layout

        A[3][0] = 1;
\end_layout

\begin_layout Plain Layout

        A[3][1] = 5;
\end_layout

\begin_layout Plain Layout

        A[3][2] = 14;
\end_layout

\begin_layout Plain Layout

        A[3][3] = 15;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Remplissage de B.
\end_layout

\begin_layout Plain Layout

        B[0] = 5;
\end_layout

\begin_layout Plain Layout

        B[1] = 1;
\end_layout

\begin_layout Plain Layout

        B[2] = 3;
\end_layout

\begin_layout Plain Layout

        B[3] = 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Factorisation de A = L*L^T.
\end_layout

\begin_layout Plain Layout

        double **L = Cholesky(A, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Résolution de LY = B.
\end_layout

\begin_layout Plain Layout

        double *Y = Sol_Inf(L, B, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Transposition de L en L^T.
\end_layout

\begin_layout Plain Layout

        Transposer(L, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Résolution de L^T*X = Y.
\end_layout

\begin_layout Plain Layout

        double *X = Sol_Sup(L, Y, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Affichage de la solution X.
\end_layout

\begin_layout Plain Layout

        printf("La solution X de AX = B d'après la méthode de Cholesky est
 : 
\backslash
n");
\end_layout

\begin_layout Plain Layout

        Afficher_Vecteur(X, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Désallocation des matrices et vecteurs.
\end_layout

\begin_layout Plain Layout

        Desallocation_Matrice(A, Taille);
\end_layout

\begin_layout Plain Layout

        Desallocation_Matrice(L, Taille);
\end_layout

\begin_layout Plain Layout

        Desallocation_Vecteur(Y);
\end_layout

\begin_layout Plain Layout

        Desallocation_Vecteur(B);
\end_layout

\begin_layout Plain Layout

        Desallocation_Vecteur(X);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // - Méthodes itératives.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // - - Jacobi.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // Définition de la taille
\end_layout

\begin_layout Plain Layout

        int Taille = 3;
\end_layout

\begin_layout Plain Layout

        // Allocation des matrices et vecteurs.
\end_layout

\begin_layout Plain Layout

        double **A = Allocation_Matrice(Taille);
\end_layout

\begin_layout Plain Layout

        double *B = Allocation_Vecteur(Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Remplissage de A
\end_layout

\begin_layout Plain Layout

        A[0][0] = 4;
\end_layout

\begin_layout Plain Layout

        A[0][1] = 1;
\end_layout

\begin_layout Plain Layout

        A[0][2] = 1;
\end_layout

\begin_layout Plain Layout

        A[1][0] = 1;
\end_layout

\begin_layout Plain Layout

        A[1][1] = 3;
\end_layout

\begin_layout Plain Layout

        A[1][2] = 1;
\end_layout

\begin_layout Plain Layout

        A[2][0] = 2;
\end_layout

\begin_layout Plain Layout

        A[2][1] = 0;
\end_layout

\begin_layout Plain Layout

        A[2][2] = 5;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Remplissage de B
\end_layout

\begin_layout Plain Layout

        B[0] = 1;
\end_layout

\begin_layout Plain Layout

        B[1] = 1;
\end_layout

\begin_layout Plain Layout

        B[2] = 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Résolution pour X.
\end_layout

\begin_layout Plain Layout

        double *X = Jacobi(A, B, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Affichage de la solution X.
\end_layout

\begin_layout Plain Layout

        printf("La solution X de AX = B avec la méthode Jacobi E est : 
\backslash
n");
\end_layout

\begin_layout Plain Layout

        Afficher_Vecteur(X, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Désallocation des matrices et vecteurs.
\end_layout

\begin_layout Plain Layout

        Desallocation_Matrice(A, Taille);
\end_layout

\begin_layout Plain Layout

        Desallocation_Vecteur(B);
\end_layout

\begin_layout Plain Layout

        Desallocation_Vecteur(X);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // - - Gauss-Seidel.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // Définition de la taille
\end_layout

\begin_layout Plain Layout

        int Taille = 3;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Allocation des matrices et vecteurs.
\end_layout

\begin_layout Plain Layout

        double **A = Allocation_Matrice(Taille);
\end_layout

\begin_layout Plain Layout

        double *B = Allocation_Vecteur(Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Remplissage de A (matrice quelconque).
\end_layout

\begin_layout Plain Layout

        A[0][0] = 4;
\end_layout

\begin_layout Plain Layout

        A[0][1] = 1;
\end_layout

\begin_layout Plain Layout

        A[0][2] = 1;
\end_layout

\begin_layout Plain Layout

        A[1][0] = 1;
\end_layout

\begin_layout Plain Layout

        A[1][1] = 3;
\end_layout

\begin_layout Plain Layout

        A[1][2] = 1;
\end_layout

\begin_layout Plain Layout

        A[2][0] = 2;
\end_layout

\begin_layout Plain Layout

        A[2][1] = 0;
\end_layout

\begin_layout Plain Layout

        A[2][2] = 5;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Remplissage de B.
\end_layout

\begin_layout Plain Layout

        B[0] = 1;
\end_layout

\begin_layout Plain Layout

        B[1] = 1;
\end_layout

\begin_layout Plain Layout

        B[2] = 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Résolution pour X.
\end_layout

\begin_layout Plain Layout

        double *X = Gauss_Seidel(A, B, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Affichage de la solution X.
\end_layout

\begin_layout Plain Layout

        printf("La solution X de AX = B avec la méthode de Gauss-Seidel
 : 
\backslash
n");
\end_layout

\begin_layout Plain Layout

        Afficher_Vecteur(X, Taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Désallocation des matrices et vecteurs.
\end_layout

\begin_layout Plain Layout

        Desallocation_Matrice(A, Taille);
\end_layout

\begin_layout Plain Layout

        Desallocation_Vecteur(B);
\end_layout

\begin_layout Plain Layout

        Desallocation_Vecteur(X);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
Ainsi, nous avons découvert plusieurs méthodes possibles pour la résolution
 d'une équation de matrice de la forme 
\begin_inset Formula $AX=B$
\end_inset

, sans calculer 
\begin_inset Formula $A^{-1}$
\end_inset

.
 Voici un récapitulatif des différentes méthodes :
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Méthode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Complexité temporelle
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Avantages
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Inconvénients
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Triangulaire inférieure
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O\left(N^{2}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- Fonctionne si 
\begin_inset Formula $A$
\end_inset

 est une matrice triangulaire inférieure.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Triangulaire supérieure
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O\left(N^{2}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- Fonctionne uniquement dans le cas où 
\begin_inset Formula $A$
\end_inset

 est une matrice triangulaire supérieure.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Élimination de Gauss
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O\left(\frac{2N^{3}}{3}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- Résolution d'un 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
La factorisation LU
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O\left(\frac{N^{3}}{3}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Méthode optimisé lorsque 
\begin_inset Formula $A$
\end_inset

 reste constant.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
La factorisation de Cholesky
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O\left(\frac{N^{3}}{6}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- Fonctionne uniquement dans le cas où 
\begin_inset Formula $A$
\end_inset

 est une matrice carrée symétrique définie positive.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Méthode de Jacobi
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O\left(3N^{2}+2N\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- Valeurs approchés
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Méthode Gauss-Seidel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O\left(N^{2}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- Valeurs approchés
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Ainsi, on constate que les méthodes ci-dessus sont complémentaires car car
 elles présentes chacune des avantages et des inconvénients.
 Ainsi, le choix de la méthode doit se faire en fonction :
\end_layout

\begin_layout Itemize
La forme de 
\begin_inset Formula $A$
\end_inset

 et 
\begin_inset Formula $B$
\end_inset

, afin d'optimiser le temps de calcul et éventuellement l'empreinte mémoire.
\end_layout

\begin_layout Itemize
La précision de la résolution.
\end_layout

\begin_layout Standard
Ainsi, il en revient à l'utilisateur de choisir quel méthode convient le
 mieux.
 Nous aurions pu éventuellement rédiger un algorithme qui fait le choix
 automatiquement.
\end_layout

\end_body
\end_document
